* 3 How To Write Function Definitions
** 3.0 
When the Lisp interpreter evaluates a list, it looks to see whether the first
symbol on the list has a function definition attached to it; put another way,
whether the symbol points to a function definition. If it does, the computer
carries out the instructions in the definitions. A symbol that has a function
definition is called, simply, a function (although, properly speaking, the
definiton is the funciton and the symbol refers to it.)

All functions are defined in terms of other functions, except for a few
primitive functions that are written in the C programming language. When you
write functions's definitions, you will write them in Emacs Lisp and use other
functions as your building blocks. Some of the functions you will use will
themselves be written in Emacs Lisp (perhaps by you) and some will be primitives
written in C. The primitive functions are used exactly like those written in
Emacs Lisp and behave like them. They are written in C so we can easily run GNU
Emacs on any computer that has sufficient power and can run C.

Let me re-emphasize this: when you write code in Emacs Lisp, you do not
distinguish between the use of functions written in C and the use of functions
written in Emacs Lisp. The difference is irrelevant. I mention the distinction
only because it is interesting to know. Indeed, unless you investigate, you
won't know whether an already-written funciton is written in Emancs Lisp or C.

** 3.1 The defun Macro

In Lisp, a symbol such as mark-whole-buffer has code attached to it that tells
the computer what to do when the function is called. This code is called the
function definition and is created by evaluating a Lisp expression that starts
with the symbol defun (which is an abbreviation for define function).

A function definition has up to five part following the word defun:

In subsequent secitons, we will look at function definitons from the Emacs
source code, such as mark-whole-buffer. In this section, we will describe a
simple funtion definition so you can see how it looks. This function definition
uses arithmetic because it makes for a simple example. Some people dislike
examples using arithmetic; however, if you remainder of this introduciton
involves arithmetic or mathematics. The examples mostly involve text in one way
or another.

1. The name of the symbol to which the function definition should be attached.
2. A list of the arguments that will be passed to the function. If no arguments
   will be passed to the function, this is an empty list, ().
3. Documentation describing the function. (Technically optional, but strongly
   recommended.)
4. Optionally, an expression to make the function interactive so you can use it
   by typing M-x and then the name of the function; or by typing an appropriate
   key or keychord.
5. The code that instructs the computer what to do: the body of the function
   definition.

#+begin_src lisp
  (defun function-name (arguments...)
    "optional-documentation..."
    (interactive argument-passing-info)       ;   optional
    body...)
#+end_src

** 3.2 Install a Function Definition
** 3.3 Make a Function Interactive
#+begin_src lisp
  (interactive "p") ;; The 'p' tells Emacs to pass the prefix argument to the function
  (interactive "p\n
#+end_src
*** 3.3.1 An Interactive multiply-by-seven
#+begin_src lisp
  (defun multiply-by-seven (number)
    "Multiply NUMBER by seven."
    (interactive "p")
    (message "The result is %d" (* 7 number)))
#+end_src

** 3.4 Different Options for interactive
#+begin_src lisp
  (interactive "p\ncZap to char: ")
#+end_src

** 3.5 Install Code Permanently
- .emacs File
- load function
- site-init.el
** 3.6 let
*** 3.6.0
*** 3.6.1 The Parts of a let Expression
Three parts of let expression
- first symbol let
- a list, called varlist
- body of the let
#+begin_src lisp
  (let varlist body...)
#+end_src
*** 3.6.2 Sample let Expression
#+begin_src lisp
  (let ((zebra "stripes")
	(tiger "fierce"))
    (message "One kind of animal has %s and another is %s."
	     zebra tiger))
#+end_src
*** 3.6.3 Uninitialized Variables in a let Statement
#+begin_src lisp
  (let ((birch 3)
	pine
	fir
	(oak 'some))
    (message
     "Here are %d variables with %s, %s, and %s value."
     birch pine fir oak))
#+end_src
>> "Here are 3 variables with nil, nil, and some value."

** 3.7 The if Special Form
#+begin_src lisp
  (if true-or-false-test
      action-to-carry-out-if-test-is-true)
#+end_src
*** 3.7.1 The type-of-animal Function in Detail
#+begin_src lisp
#+end_src
** 3.8 If-then-else Expressions
#+begin_src lisp
  (if true-or-false-test
      action-to-carry-out-if-test-returns-true
    action-to-carry-out-if-the-test-returns-false)
#+end_src
#+begin_src lisp
  (if (> 4 5)                                ; if-part
      (message "4 falsely greater than 5!")  ; then-part
    (message "4 is not greater than 5!"))    ; else-part
#+end_src
