* 3 How To Write Function Definitions
** 3.0 
When the Lisp interpreter evaluates a list, it looks to see whether the first
symbol on the list has a function definition attached to it; put another way,
whether the symbol points to a function definition. If it does, the computer
carries out the instructions in the definitions. A symbol that has a function
definition is called, simply, a function (although, properly speaking, the
definiton is the funciton and the symbol refers to it.)

All functions are defined in terms of other functions, except for a few
primitive functions that are written in the C programming language. When you
write functions's definitions, you will write them in Emacs Lisp and use other
functions as your building blocks. Some of the functions you will use will
themselves be written in Emacs Lisp (perhaps by you) and some will be primitives
written in C. The primitive functions are used exactly like those written in
Emacs Lisp and behave like them. They are written in C so we can easily run GNU
Emacs on any computer that has sufficient power and can run C.

Let me re-emphasize this: when you write code in Emacs Lisp, you do not
distinguish between the use of functions written in C and the use of functions
written in Emacs Lisp. The difference is irrelevant. I mention the distinction
only because it is interesting to know. Indeed, unless you investigate, you
won't know whether an already-written funciton is written in Emancs Lisp or C.

** 3.1 The defun Macro

In Lisp, a symbol such as mark-whole-buffer has code attached to it that tells
the computer what to do when the function is called. This code is called the
function definition and is created by evaluating a Lisp expression that starts
with the symbol defun (which is an abbreviation for define function).

A function definition has up to five part following the word defun:

In subsequent secitons, we will look at function definitons from the Emacs
source code, such as mark-whole-buffer. In this section, we will describe a
simple funtion definition so you can see how it looks. This function definition
uses arithmetic because it makes for a simple example. Some people dislike
examples using arithmetic; however, if you remainder of this introduciton
involves arithmetic or mathematics. The examples mostly involve text in one way
or another.

1. The name of the symbol to which the function definition should be attached.
2. A list of the arguments that will be passed to the function. If no arguments
   will be passed to the function, this is an empty list, ().
3. Documentation describing the function. (Technically optional, but strongly
   recommended.)
4. Optionally, an expression to make the function interactive so you can use it
   by typing M-x and then the name of the function; or by typing an appropriate
   key or keychord.
5. The code that instructs the computer what to do: the body of the function
   definition.

#+begin_src lisp
  (defun function-name (arguments...)
    "optional-documentation..."
    (interactive argument-passing-info)       ;   optional
    body...)
#+end_src

** 3.2 Install a Function Definition
** 3.3 Make a Function Interactive
#+begin_src lisp
  (interactive "p") ;; The 'p' tells Emacs to pass the prefix argument to the function
  (interactive "p\n
#+end_src
*** 3.3.1 An Interactive multiply-by-seven
#+begin_src lisp
  (defun multiply-by-seven (number)
    "Multiply NUMBER by seven."
    (interactive "p")
    (message "The result is %d" (* 7 number)))
#+end_src

** 3.4 Different Options for interactive
#+begin_src lisp
  (interactive "p\ncZap to char: ")
#+end_src

** 3.5 Install Code Permanently
- .emacs File
- load function
- site-init.el
** 3.6 let
*** 3.6.0
*** 3.6.1 The Parts of a let Expression
Three parts of let expression
- first symbol let
- a list, called varlist
- body of the let
#+begin_src lisp
  (let varlist body...)
#+end_src
*** 3.6.2 Sample let Expression
#+begin_src lisp
  (let ((zebra "stripes")
	(tiger "fierce"))
    (message "One kind of animal has %s and another is %s."
	     zebra tiger))
#+end_src
*** 3.6.3 Uninitialized Variables in a let Statement
未初始化变量（没有赋值的）
#+begin_src lisp
  (let ((birch 3)
	pine      ;; return nil
	fir       ;; return nil
	(oak 'some))
    (message
     "Here are %d variables with %s, %s, and %s value."
     birch pine fir oak))
#+end_src
>> "Here are 3 variables with nil, nil, and some value."

** 3.7 The if Special Form
#+begin_src lisp
  (if true-or-false-test
      action-to-carry-out-if-test-is-true)
#+end_src
*** 3.7.1 The type-of-animal Function in Detail
#+begin_src lisp
  (defun name-of-funciton (argment-list)
    "documentation..."
    body...)
  (defun type-of-animal (characteristic)
    "Print message in echo area depending on CHARACTERISTIC.
  If the CHARACTERISTIC is the string \"fierce\",
  then warn of a tiger."
    body: the if expression)
  (if true-or-false-test
      action-to-carry-out-if-the-test-returns-true)
  (if (equal characteristic "fierce")
      (message "It is a tiger!"))
  (equal characteristic "fierce")
#+end_src
** 3.8 If-then-else Expressions
#+begin_src lisp
  (if true-or-false-test
      action-to-carry-out-if-test-returns-true
    action-to-carry-out-if-the-test-returns-false)
#+end_src
#+begin_src lisp
  (if (> 4 5)                                ; if-part
      (message "4 falsely greater than 5!")  ; then-part
    (message "4 is not greater than 5!"))    ; else-part
#+end_src
An if expression may have an optional third argument,
An if expression may have an optional third argument,
An if expression may have an optional third argument,
An if expression may have an optional third argument,
called else-part,
called else-part,
called else-part,
called else-part,
for the case when thr true-or-false-test return false.
for the case when the true-or-false-test return false.
for the case when the ture-or-false-test return false.
for the case when the true-or-false-test return false.
for the case when the true-or-false-test return false.
When this happens,
When this happens,
When this happens,
When this happens,
When this happens,
the second argument or then-part of the overall if expression is not evaluated,
the second argument or then-part of the overall if expression is not evaluated,
the second argument or then-part of the overall if expression is not evaluated,
the second argument or then-part of the overall if expression is not evaluated,
the second argument or then-part of the overall if expression is not evaluated,
but the third or else-part is evaluated.
but the third or else-part is evaluated.
but the third or else-part is evaluated.
but the third or else-part is evaluated.
but the third or else-part is evaluated.
You might think of this as the cloudy day alternative for the decision
"if it is warm and sunny, then go to the beach, else read a book!".
You might think of this as the cloudy day alternative for the decision
"if it is warm and sunny, then go to the beach, else read a book!".
You might think of this as the cloudy day alternative for the decision
"if it is warm and sunny, then go to the beach, else read a book!".
The word "else" is not written in the Lisp code;
The word "else" is not written in the Lisp code;
The word "else" is not written in the Lisp code;
The word "else" is not written in the Lisp code;
the else-part of an if expression comes after the then part.
the else-part of an if expression comes after the then part.
the else-part of an if expression comes after the then part.
the else-part of an if expression comes after the then part.
the else-part of an if expression comes after the then part.
In the written Lisp,
In the written Lisp,
In the written Lisp,
In the written Lisp,
In the written Lisp,
the else-part is usually written to start on a line of its own and is
indented less than the then-part:
the else-part is usually written to start on a line of its own and is
indented less than the then-part:
一个if表达式可能有第三个可选参数，叫else-part，当true-or-false-test返
回false时。当这个发生时，第二个参数或者说整个if表达式的（then-part）没
有求值，但是第三部分（或else-part）求值。就像你多云的时候做决定，如果
温暖有阳光就区海滩，否则就在家看书。
else没有写在Lisp code中；if的else-part在then-part之后。在写Lisp时，
else-part通常单独一行，缩进比then-part要小一点。
#+begin_src lisp
  (if true-or-false-test
      action-to-carry-out-if-the-test-returns-true ;; indent more
    action-to-carry-out-if-the-test-returns-false) ;; indent less
#+end_src
For example, For example, For example
the following if expression prints the message '4 is not greater than
5!'
the following if expression prints the message '4 is not greater than
5!'
when you evaluate it in the usual way:
when you evaluate it in the usual way
when you evaluate it in the usual way:
when you evaluate it in the usual way:
when you evaluate it in the usual way:
#+begin_src lisp
  (if (> 4 5)                                ; if-part
      (message "4 falsely greater than 5!")  ; then-part
    (message "4 is not greater than 5!"))    ; else-part
#+end_src
Note that the different levels of indentation make it easy to
distinguish the then=part from the else-part.
Note that the different levels of indentation make it easy to
distinguish the then-part from the else-part.
Note that the different levels of indentation make it easy to
distinguish the then-part from the else-part.
Note that the different levels of indentation make it easy to
distinguish the then-part from the else-part.
We can extend the type-of-animal function to include an else-part by
simply incorporating an additional part to the if expression.
We can extend the type-of-animal function to include an else-part by
simply incorporating an additional part to the if expression.
We can extend the type-of-animal function to include an else-part by
simply incorporating an additional part to the if expression.
You can see the consequences of doing this if you evaluate the
following version of the type-of-animal function definition to install
it and then evaluate the two subsequent expressions to pass different
arguments to the function.
You can see the consequences of doint this if you evaluate the
following version of the type-of-animal function definition to install
it and then evaluate the two subsequent expressions to pass different
arguments to the function.
When you evaluate (type-of-animal "fiere"), you will see the following
message printed in the echo area: "It is a tiger!"; but when you
evaluate (type-of-animal "striped"), you will see "It is not fierce!".
(Of course, if the characteristic were "ferocious", the message "It is
not fierce!" would be printed; and it would be misleading! When you
write code, you need to take into account the possibility that some
such argument will be tested by the if and write your program accordingly.)

** 3.9 Truth and Falsehood in Emacs Lisp
There is an important aspect to the truth test in an if expression. So
far, we have spoken of "true and "false" as values of predicates as if
they were new kinds of Emacs Lisp objects. In fact, "false" is just
our old friend nil. Anything else-anything at all is "true".
false = nil = ()

The expression that tests for truth is interpreted as true if the
result of evaluating it is a value that is not nil. In other words,
the result of the test is considered true if the value returned is a
number such as 47, a string such as "hello", or a symbol (other than
nil) such as flowers, or a list(so long as it is not empty), or even a
buffer!

Before illustrating a test for truth, we need an explanation of nil.

#+begin_src lisp
  (if 4
      'true
    'false) ;; true
  (if nil
      'true
    'false) ;; false
  (if ()
      'true
    'false) ;; false
#+end_src

** 3.10 save-excursion

The save-excursion function is the third and final special form that
we will discuss in this chapter.
The save-excursion function is the third and final special form that
we will discuss in this chapter.
The save-excursion function is the third and final special form that
we will discuss in this chapter.
The save-excursion function is the third and final special form that
we will discuss in this chapter.
The save-excursion function is the third and final special form that
we will discuss in this chapter.

In Emacs Lisp programs used for editing, the save-excursion function
is very common.
In Emacs Lisp programs used for editing, the save-excursion function
is very common.
In Emacs Lisp programs used for editing, the save-excursion function
is very common.
In Emacs Lisp programs used for editing, the save-excursion function
is very common.
In Emacs Lisp programs used for editing, the save-excursion function
is very common.
It saves the location of point,
It saves the location of point,
It saves the location of point,
It saves the location of point,
It saves the location of point,
executes the body of the function,
executes the body of the function,
executes the body of the function,
executes the body of the function,
executes the body of the function,
and then restores point to its previous position if its location was
changed.
and then restores point to its previous position if its location was
changed. 
and then restores point to its previous position if its location was
changed. 
and then restores point to its previous position if its location was
changed. 
and then restores point to its previous position if its location was
changed.
It saves the location of the point,
executes the body of the function.
and then restores point to its previous position if its location was
changed. 
Its primary purpose is to keep the user from begin surprised and
disturbed by unexpected movement of point.
Its primary purpose is to keep the user from begin surprised and
disturbed by unexpected movement of point.
Its primary purpose is to keep the user from begin surprised and
disturbed by unexpected movement of point.
Its primary purpose is to keep the user form begin surprised and
disturbed by unexpected movement of point.
Before discussing save-excursion,
Before discussing save-excursion,
Before discussing save-excursion,
Before discussing save-excursion,
however,
however,
however,
however,
however,
it may be useful first to review what point and mark are in GNU Emacs.
it may be useful first to review what point and mark are in GNU Emacs.
it may be useful first to review what point and mark are in GNU Emacs.

Point is the current location of the cursor. 
Point is the current location of the cursor.
Point is the current location of the cursor.
Point is the current location of the cursor.
Point is the current location of the cursor.

Wherever the cursor is, that is the point.
Wherever the cursor is, that is the point.
Wherever the cursor is, that is the point.
Wherever the cursor is, that is the point.
Wherever the cursor is, that is the point.

More precisely
More precisely
More precisely
More precisely
More precisely
on terminals where the cursor appears to be on top of a character,
on terminals where the cursor appears to be on top of a character,
on terminals where the cursor appears to be on top of a character,
on terminals where the cursor appears to be on top of a character,
on terminals where the cursor appears to be on top of a character,
point is immediately before the character.
point is immediately before the character.
point is immediately before the character.
point is immediately before the character.
point is immediately before the character.
In Emacs Lisp, point is an integer.
In Emacs Lisp, point is an integer.
In Emacs Lisp, point is an integer.
In Emacs Lisp, point is an integer.
In Emacs Lisp, point is an integer.
The first character in a buffer is number one,
The first character in a buffer is number one,
The first character in a buffer is number one,
The first character in a buffer is number one,
The first character in a buffer is number one,
the second is number two, and so on.
the second is number two, and so on.
the second is number two, and so on.
the second is number two, and so on.
the second is number two, and so on.
The function point returns the current position of the cursor as a
number.
The function point returns the current position of the cursor as a
number. 
The function point returns the current position of the cursor as a
number. 
The function point returns the current position of the cursor as a
number. 
Each buffer has its own value for point.
Each buffer has its own value for point.
Each buffer has its own value for point.
Each buffer has its own value for point.
Each buffer has its own value for point.

save-excursion 函数
保存当前的point
执行函数body
如果point改了就恢复原来位置。

point 和 mark
point是cursor当前位置
在Emacs Lisp Programs是一个整数
第一个字符的位置是1，第二个是2以此类推；
每个buffer都有自己的point
（point）函数返回cursor当前的位置（一个数字）

The mark is another position in the buffer;
The mark is another position in the buffer;
The mark is another position in the buffer;
The mark is another position in the buffer;
The mark is another position in the buffer;
its value can be set with a command such as C-SPC (set-mark-command).
its value can be set with a command such as C-SPC (set-mark-command).
its value can be set with a command such as C-SPC (set-mark-command).
its value can be set with a command such as C-SPC (set-mark-command).
its value can be set with a command such as C-SPC (set-mark-command).
If a mark has been set, you can use the command C-x C-x
(exchange-point-and-mark) to cause the cursor to jump to the mark and
set the mark to be the previous position of point.
If a mark has been set,
If a mark has been set,
If a mark has been set,
If a mark has been set,
If a mark has been set,
you can use the command C-x C-x (exchange-point-and mark)
you can use the command C-x C-x (exchange-point-and-mark)
you can use the command C-x C-x (exchange-point-and-mark)
you can use the command C-x C-x (exchange-point-and-mark)
you can use the command C-x C-x (exchange-point-and-mark)
to cause the cursor to jump to the mark
to cause the cursor to jump to the mark
to cause the cursor to jump to the mark
to cause the cursor to jump to the mark
to cause the cursor to jump to the mark
and set the mark to be the previous position of the point.
and set the mark to be the previous position of the point.
and set the mark to be the previous position of the point.
and set the mark to be the previous position of the point.
and set the mark to be the previous position of the point.
In addition, In addition, In addition, In addition, In addition,
if you set another mark,
if you set another mark,
if you set another mark,
if you set another mark,
if you set another mark,
the position of the previous mark is saved in the mark ring.
the position of the previous mark is saved in the mark ring.
the position of the previous mark is saved in the mark ring.
the position of the previous mark is saved in the mark ring.
the position of the previous mark is saved in the mark ring.

Many mark positions can be saved this way.
Many mark positions can be saved this way.
Many mark positions can be saved this way.
Many mark positions can be saved this way.
Many mark positions can be saved this way.
You can jump the cursor to a saved mark by typing C-u C-SPC one or
more times.
You can jump the cursor to a saved mark by typing C-u C-SPC one or
more times.
You can jump the cursor to a saved mark by typing C-u C-SPC one or
more times.
You can jump the cursor to a saved mark by typing C-u C-SPC one or
more times.
You can jump the cursor to a saved mark by typing C-u C-SPC one or
more times.
mark是另一buffer中的位置，你可以设置一个mark用C-SPC（set-mark-command）
如果一个mark被set，你能用C-x C-x（exchange-point-and-mark）在point和
mark间跳转位置，另外，如果你已经设置过mark，这个新mark会加入mark-ring
中。许多mark positions都是这么保存的，你可以C-u C-SPC多次跳转到mark位
置。
mark小结：
C-SPC（set-mark-command)
C-x C-x (exchange-point-and-mark)
C-u C-SPC [jump to the previous marks] You can run it 

The part of the buffer between point and mark is called the region.
The part of the buffer between point and mark is called the region.
The part of the buffer between point and mark is called the region.
The part of the buffer between point and mark is called the region.
The part of the buffer between point and mark is called the region.
Numerous commands work on the region,
Numerous commands work on the region,
Numerous commands work on the region,
Numerous commands work on the region,
Numerous commands work on the region,

including center-region, count-lines-region, kill-region, and
print-region.
including center-region, count-lines-region, kill-region, and
print-region. 
including center-region, count-lines-region, kill-region, and
print-region. 
including center-region, count-lines-region, kill-region, and
print-region. 

The save-excursion special form saves the location of point and
restores this position after the code within the body of the special
form is evaluated by the Lisp interpreter.
The save-excursion special form saves the location of point and
restores this position after the code within the body of the special
form is evaluated by the Lisp interpreter.
The save-excursion special form saves the location of point and
restores this position after the code within the body of the special
form is evaluated by the Lisp interpreter.

Thus, if point were in the beginning of a piece of text and some code
moved point to the end of the buffer, 
Thus, if point were in the beginning of a piece of text and some code
moved point to the end of the buffer, 
Thus, if point were in the beginning of a piece of text and some code
moved point to the end of the buffer,
Thus, if point were in the beginning of a piece of text and some code
moved point to the end of the buffer,
Thus, if point were in the beginning of a piece of text and some code
moved point to the end of the buffer,,

the save-excursion would put point back to where it was before, after
the expression in the body of the function were evaluated.
the save-excursion would put point back to where it was before, after
the expression in the body of the function were evaluated.
the save-excursion would put point back to where it was before, after
the expression in the body of the function were evaluated.
the save-excursion would put point back to where it was before, after
the expression in the body of the function were evaluated.

In Emacs, a function frequently moves point as part of its internal
working even though a user would not expect this.
In Emacs, a function frequently moves point as part of its internal
working even though a user would not expect this.
In Emacs, a function frequently moves point as part of its internal
working even though a user would not expect this.
In Emacs, a function frequently moves point as part of its internal
working even though a user would not expect this.
In Emacs, a function frequently moves point as part of its internal
working even though a user would not expect this.

For example, count-lines-region moves point.
For example, count-lines-region moves point.
To prevent the user from being bothered by jumps that are both
unexpected and (from the user's point of view) unnecessary,
To prevent the user from being bothered by jumps that are both
unexpected and (from the user's point of view) unnecessary,
save-excursion is often used to keep point in the location expected by
the user. 
save-excursion is often used to keep point in the location expected by
the user.
save-excursion is often used to keep point in the location expected by
the user.
save-excursion is often used to keep point in the location expected by
the user.

The use of save-excursion is good housekeeping.
The use of save-excursion is good housekeeping.
The use of save-excursion is good housekeeping.
The use of save-excursion is good housekeeping.
The use of save-excursion is good housekeeping.

To make sure the house stays clean,
To make sure the house stays clean,
To make sure the house stays clean,
To make sure the house stays clean,
To make sure the house stays clean,

save-excursion restores the value of point even if something goes
wrong in the code inside of it (or, to be more precise and to use the
proper jargon, "in case of abnormal exit"). 
save-excursion restores the value of point even if something goes
wrong in the code inside of it (or, to be more precise and to use the
proper jargon, "in case of abnormal exit").
This feature is very helpful.
This feature is very helpful.
This feature is very helpful.
This feature is very helpful.
This feature is very helpful.

In addition to recording the value of point,
In addition to recording the value of point,
In addition to recording the value of point,
In addition to recording the value of point,
In addition to recording the value of point,

save-excursion keeps track of the current buffer,
save-excursion keeps track of the current buffer,
save-excursion keeps track of the current buffer,
save-excursion keeps track of the current buffer,
save-excursion keeps track of the current buffer,

(keep-track-of)

and restores it, too.
and restores it, too.
and restores it, too.
and restores it, too.
and restores it, too.

(restore)

This means you can write code that will change the buffer and have
save-excursion switch you back to the original buffer.
This means you can write code that will change the buffer and have
save-excursion switch you back to the original buffer.
This means you can write code that will change the buffer and have
save-excursion switch you back to the original buffer.
This means you can write code that will change the buffer and have
save-excursion switch you back to the original buffer.

This is how save-excursion is used in append-to-buffer.
This is how save-excursion is used in append-to-buffer.
This is how save-excursion is used in append-to-buffer.
This is how save-excursion is used in append-to-buffer.
This is how save-excursion is used in append-to-buffer.

*** 3.10.1 Template for a save-excursion Expression
The template for the using save-excursion is simple:
#+begin_src lisp
  (save-excursion
    body...)
#+end_src
The body of the function is one or more expressions that will be
evaluated in sequence by the Lisp interpreter.
The body of the function is one or more expressions that will be
evaluated in sequence by the Lisp interpreter.
The body of the function is one or more expressions that will be
evaluated in sequence by the Lisp interpreter.
The body of the function is one or more expressions that will be
evaluated in sequence by the Lisp interpreter.

If there is more than one expression in the body,
If there is more than one expression in the body,
If there is more than one expression in the body,
If there is more than one expression in the body,
If there is more than one expression in the body,

the value of the last one will be returned as the value of the
save-excursion function.
the value of the last one will be returned as the value of the
save-excursion function.
the value of the last one will be returned as the value of the
save-excursion function.
the value of the last one will be returned as the value of the
save-excursion function.

The other expressions in the body are evaluated only for their side
effects;
The other expressions in the body are evaluated only for their side
effects;
The other expressions in the body are evaluated only for their side
effects; 
The other expressions in the body are evaluated only for their side
effects;

and save-excursion itself is used only for its side effect (which is
restoring the position of point).
and save-excursion itself is used only for its side effect (which is
restoring the position of point).
and save-excursion itself is used only for its side effect (which is
restoring the position of point).


** 3.12 Exercises
#+begin_src lisp
  ;; 3.12 Exercises
  (defun double-number (num)
    (* 2 num))
  (double-number 2)
  (defun double-number-interactive (num)
    (interactive "p")
    (message "%d" (* 2 num)))


  (double-number-interactive 2)

  (defun test-fill-column (arg)
    (if (> fill-column arg)
	(message "fill-column is larger than arg")
      (message "fill-column is not larger than arg")))
  (test-fill-column 32)

  (exchange-point-and-mark)

  (defun simplified-beginning-of-buffer ()
    "Move point to theh beginning of the uffer;
  leave mark at previous position."
    (interactive)
    (push-mark)
    (goto-char (point-min)))

  (defun test-install-permanently()
    "doc..."
    (interactive)
    (message "test succesful for load function"))
#+end_src
